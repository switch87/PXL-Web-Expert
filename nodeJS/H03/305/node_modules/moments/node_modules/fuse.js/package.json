{
  "name": "fuse.js",
  "author": {
    "name": "Kirollos Risk"
  },
  "version": "1.3.1",
  "description": "Lightweight fuzzy-search",
  "license": "Apache",
  "main": "./src/fuse.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/krisk/Fuse.git"
  },
  "dependencies": {},
  "scripts": {
    "test": "vows --spec"
  },
  "devDependencies": {
    "vows": "0.5.x",
    "grunt-bump": "0.0.11",
    "uglify-js": "*"
  },
  "readme": "*Update: There are plenty of enhancements that need to be done to this library. There's more work than available time for me; so if you're interested in being one of the core contributors and helping out, let's talk!*\n\nFuse\n====\n\n[![NPM](https://nodei.co/npm/fuse.js.png?downloads=true)](https://nodei.co/npm/fuse.js/)\n\n[![Build Status](https://secure.travis-ci.org/krisk/Fuse.png?branch=master)](http://travis-ci.org/krisk/Fuse)\n\nFuse is a full JavaScript fuzzy-search implementation that searches accross the keys of every record in a list.\n\n- [Demo & usage](http://kiro.me/exp/fuse.html)\n- [Project page](http://kiro.me/projects/fuse.html)\n\n## Options\n\n**keys** (*type*: `Array`)\n\nList of properties that will be searched.  This also supports nested properties:\n\n```javascript\nvar books = [{\n  title: \"Old Man's War\"\n  author: {\n    firstName: \"John\",\n    lastName: \"Scalzi\"\n  }\n}];\nvar fuse = new Fuse(books, { keys: [\"title\", \"author.firstName\"] });\n```\n\n---\n\n**id** (*type*: `String`)\n\nThe name of the identifier property. If specified, the returned result will be a list of the items' identifiers, otherwise it will be a list of the items.\n\n---\n\n**caseSensitive** (*type*: `Boolean`, *default*: `false`)\n\nIndicates whether comparisons should be case sensitive.\n\n---\n\n**include** (*type*: `Array`, *default*: `[]`)\n\nAn array of values that should be included from the searcher's output. When this array contains elements, each result in the list will be of the form `{ item: ..., include1: ..., include2: ... }`. For example, to include the score, you would set include to ['score'], and the result would be `{ item: ..., score: ... }`\n\n---\n\n**shouldSort** (*type*: `Boolean`, *default*: `true`)\n\nWhether to sort the result list, by score.\n\n---\n\n**searchFn** (*type*: `Function`, *default*: `BitapSearcher`)\n\nThe search function to use.  Note that the search function (`[[Function]]`) must conform to the following API:\n\n```javascript\n/*\n@param pattern The pattern string to search\n@param options The search option\n*/\n[[Function]].constructor = function(pattern, options) { ... }\n\n/*\n@param text: the string to search in for the pattern\n@return Object in the form of:\n - isMatch: boolean\n - score: Int\n */\n[[Function]].prototype.search = function(text) { ... }\n```\n\n---\n\n**getFn** (*type*: `Function`, *default*: `Utils.deepValue`)\n\nThe get function to use when fetching an object's properties.  The default will search nested paths *ie foo.bar.baz*\n\n```javascript\n/*\n@param obj The object being searched\n@param path The path to the target property\n*/\n\n// example using an object with a `getter` method\ngetFn: function (obj, path) {\n  return obj.get(path);\n}\n```\n---\n\n**sortFn** (*type*: `Function`, *default*: `Array.prototype.sort`)\n\nThe function that is used for sorting the result list.\n\n### Bitap specific options\n\n**location** (*type*: `Integer`, *default*: `0`)\n\nDetermines approximately where in the text is the pattern expected to be found.\n\n---\n\n**threshold** (*type*: `Decimal`, *default*: `0.6`)\n\nAt what point does the match algorithm give up. A threshold of `0.0` requires a perfect match (of both letters and location), a threshold of `1.0` would match anything.\n\n---\n\n**distance** (*type*: `Integer`, *default*: `100`)\n\nDetermines how close the match must be to the fuzzy location (specified by `location`). An exact letter match which is `distance` characters away from the fuzzy location would score as a complete mismatch. A `distance` of `0` requires the match be at the exact `location` specified, a `threshold` of `1000` would require a perfect match to be within 800 characters of the `location` to be found using a `threshold` of `0.8`.\n\n---\n\n**maxPatternLength** (*type*: `Integer`, *default*: `32`)\n\nThe maximum length of the pattern. The longer the pattern, the more intensive the search operation will be.  Whenever the pattern exceeds the `maxPatternLength`, an error will be thrown.  Why is this important? Read [this](http://en.wikipedia.org/wiki/Word_(computer_architecture)#Word_size_choice).\n\n## Methods\n\n**search(pattern)**\n\n@param {String} pattern The pattern string to fuzzy search on.  \n@return {Array} A list of all serch matches.  \n\nSearches for all the items whose keys (fuzzy) match the pattern.\n\n**set(list)**\n\n@param {Array} list  \n@return {Array} The newly set list  \n\nSets a new list for Fuse to match against.\n\n## Contributing to Fuse\n\nBefore submitting a pull request, please add relevant tests in `test/fuse-test.js`, and execute them via `npm test`.\n\nNote that **ALL TESTS MUST PASS**, otherwise the pull request will be automatically rejected.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/krisk/Fuse/issues"
  },
  "_id": "fuse.js@1.3.1",
  "_from": "fuse.js@^1.3.1"
}
